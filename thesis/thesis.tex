\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage[document]{ragged2e}
% \usepackage[a4paper, total={5in, 8in}]{geometry}
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{float}
\usepackage[colorlinks=true,breaklinks=false]{hyperref}
\usepackage{listings}
\usepackage[norelsize,ruled,vlined]{algorithm2e}
\usepackage{csquotes}
\usepackage{url}
\usepackage{ifthen}
\usepackage{keyval}
\usepackage{etoolbox}
\usepackage{etex}
\usepackage{datetime}
\usepackage{eurosym}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{paralist}
\usepackage[backend=bibtex]{biblatex}
\usepackage{xcolor}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3} } }
\captionsetup[lstlisting]{format=listing, labelfont=white, textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize} }

% \hyphenpenalty=10000
\pretolerance=10000
\tolerance=2000
\emergencystretch=0pt
\addbibresource{project.bib}
\newcommand{\scalafmt}{\texttt{scalafmt}}

% Single spacing after dots and colons
\frenchspacing
% \hyphenation{directembedding}
% \hyphenation{DSLVirtualization}
% \hyphenation{ReificationTransformation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        Setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{scala}{
  language=Scala,
  aboveskip=3mm,
  basicstyle=\scriptsize\ttfamily,
  belowskip=3mm,
  breakatwhitespace=false,
  showspaces=false,
  showlines=true,
  columns=flexible,
  keepspaces=true,
  commentstyle=\color{dkgreen},
  keywordstyle=\color{blue},
  numbers=left,
  numberstyle=\tiny\color{gray},
  showstringspaces=false,
  stepnumber=1,
}


\include{sections/settings}
\include{sections/cover}
\include{sections/abstract}
\begin{abstract}
  Automatic code formatters bring many benefits to software development, yet they can be tricky to get right.
  This thesis addresses the problem of developing a code formatter for the
  Scala programming language that captures the language's most popular idioms
  and coding styles.
  Our work has been limited to formatting Scala code.
  Still, we have developed data structures, algorithms and tools that we
  believe can applied to develop code formatters for a variety of other
  programming languages.
\end{abstract}
\tableofcontents
% \include{sections/introduction}
\pagebreak
\section{Introduction} % (fold)
\label{sec:Introduction}
\lstset{style=scala}

The main motivation of this study is to bring a robust, configurable and opinionated code formatter to the Scala community.
Although there already exist Scala code formatters,
we consider that they do not capture many popular coding styles which are present in the Scala community.

Code formatters are used by software developers to apply stylistic formatting conventions on their source code.
Without code formatters, software developers are responsible for manipulating all syntactic trivia in their code.
Syntactic trivia includes where to put spaces, insert newlines and how far to indent code fragments.
Consider the Scala code snippets in listings~\ref{lst:unformatted} and~\ref{lst:formatted1}.

\begin{minipage}{.45\textwidth}
\lstinputlisting[label={lst:unformatted}, caption=Unformatted code]{code/unformatted.scala}
\end{minipage}
\hfil
\begin{minipage}{.45\textwidth}
\lstinputlisting[label={lst:formatted1}, caption=Formatted code]{code/target/formatted1.scala}
\end{minipage}
\hfil
Both snippets represent the same program.
The only difference lies in their formatting.
% The snippet in listing~\ref{lst:formatted1} is result of running \scalafmt{} on listing~\ref{lst:unformatted} with a constrait of fitting maximum 35 characters on each line.
Listing~\ref{lst:formatted1} is arguably easier to read and understand.
For example, listing~\ref{lst:unformatted} makes it unclear which function call \texttt{arg6} belongs to.


Moreover, in collaborative environments without code formatters,
the responsibility is left to code reviewers to verify that each contributed software patch adheres to the organizations coding style conventions.



This thesis addresses the problem of automatically converting any Scala program, such as in listing~\ref{lst:unformatted}, to a well formatted program, such as in listing~\ref{lst:formatted1}.
% This example is interesting challenges of developing a code formatter for Scala.
% Most importantly, many popular coding styles enforce a column-width limit.
% such as the Scala.js coding style~\autocite{scalajs}

The motivation to use code formatters is manifold.
Code formatters enforce a consistent coding style in a code base that's touched by multiple developers.
By delegating mundane formatting tasks to a formatter, software developers are able to invest their attention to 

Code formatting enables automated refactoring tools, see~\autocite{wright_large-scale_2013}.
Code formatting also lowers the barrier to entry for novice programmers, who are not aware of the coding style conventions.

Code formatters have existed for a long time.
In more recent years we've seen many new opimization based code formatters, such as clang-format, dartfmt and rfmt.
Optimization based code formatters define a fit function for a given layout.
A good layout has low cost while a bad layout has a high cost.
The formatter runs an algorithm to choose the layout with the lowest code.
This idea is not new, for example TeX uses a fit function to optimally break lines
in text documents.

Much work has been put into developing language agnostic code formatters or pretty printers.
Researchers of such work correctly highlights that developing a custom code formatter for each language requires a lot of effort.
It may be possible that we find a perfect way to develop language independent code formatters, see~\autocite{mps_article}.
Still, today no such framework exists and people who write Scala code each day are still choosing to manually format their code.
The goal of this thesis is not to address language agnostic code formatting.

\subsection{Problem statement}
This thesis addresses the problem of developing a code formatter, \scalafmt, for the Scala programming language.
This formatter should:
\begin{itemize}
  \item capture Scala's most common idioms and popular coding styles, most importanly a line length limit.
  \item be opinionated, it should be able to produce nice looking code even for the most egregiously formatted input.
  \item be fast, <200ms for 99 percentile of source files, <2s for rest.
\end{itemize}

\subsection{Contributions}
The main contributions presented in this thesis are the following:
\begin{itemize}
    \item We have developed a framework of data structures, algorithms and tooling that help
      developing code formatters. This work is presented in section X.
    \item We have applied this framework to develop \scalafmt, a code
      formatter for the Scala programming language.
\end{itemize}

\section{Background}
\subsection{Scala the programming language}
Throughout the paper we assume familiarity with the basics of the Scala
Programming Language~\autocite{odersky_scala_2004}.
\subsubsection{Pattern matching}
\subsubsection{Higher order functions}
\subsubsection{For comprehensions}
\subsubsection{Dialects}
\subsubsection{Metaprogramming with scala.meta}
\begin{itemize}
  \item Tree nodes have parent links.
  \item Token classes are types.
\end{itemize}
\subsection{Code formatting}
\subsubsection{gofmt}
\subsubsection{rustfmt}
\subsubsection{dartfmt}
\subsubsection{clang-format}
\subsubsection{scalariform}
\section{scalafmt}
\subsection{Data structures}
\subsubsection{FormatToken}
\subsubsection{Split combinator}
\subsubsection{Policy combinator}
\subsubsection{OptimalToken combinator}
\subsubsection{State}
\subsubsection{Indent}
\subsection{Algorithms}
Pipeline of three stages: pre-processing, line wrapping and post-processing.
\subsubsection{Pre-processing???}
 \begin{itemize}
   \item AST vs. token stream
 \end{itemize}
rustfmt considers that all eventually converge to a hybrid of the two.
Indeed, clang-format has an elaborate parser.
\subsubsection{BestFirstSearch}
\begin{itemize}
  \item Router
  \item Search.
\end{itemize}
\subsubsection{FormatWriter}
\begin{itemize}
  \item vertical alignment
  \item comment formatting
  \item stripMargin alignment
\end{itemize}
\subsection{Heatmaps}
\subsection{Configuration}
\subsubsection{maxColumn}
\subsubsection{binPacking}
\subsubsection{vertical alignment}
\subsection{Optimizations}
\subsubsection{dequeueOnNewStatements}
\subsubsection{recurseOnBlocks}
\subsubsection{escapeInPathologicalCases}
\subsubsection{escapeInPathologicalCases}
\subsubsection{pruneSlowStates}
\subsection{Unit tests}
\subsection{Property based tests}
\subsubsection{AST Integrity}
\subsubsection{Idempotency}
\subsection{Regressions tests}
\section{Evaluation}
\subsection{Micro benchmarks}
\subsection{Adoption}
\section{Related work}
\subsection{Combinator based}
\begin{enumerate}
  \item Houghes 1995
  \item Wadler 1999
\end{enumerate}
\subsection{Optimization-oriented}
\begin{enumerate}
  \item clang-format Dijkstra's 2010
  \item dartfmt Best-first search 2014
  \item rfmt 2015
\end{enumerate}
\begin{enumerate}
  \item Optimal line breaking
  \item Oppen
\end{enumerate}
\section{Discussion}
\subsection{Future work}
\subsection{Conclusion}
\printbibliography{}

\end{document}


