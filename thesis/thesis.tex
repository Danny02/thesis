\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{float}
\usepackage[colorlinks=true,breaklinks=false]{hyperref}
\usepackage{listings}
\usepackage[norelsize,ruled,vlined]{algorithm2e}
\usepackage{csquotes}
\usepackage{url}
\usepackage{ifthen}
\usepackage{keyval}
\usepackage{etoolbox}
\usepackage{etex}
\usepackage{datetime}
\usepackage{eurosym}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{paralist}
\usepackage{biblatex}
\usepackage{xcolor}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3} } }
\captionsetup[lstlisting]{format=listing, labelfont=white, textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize} }

\addbibresource{project.bib}

% Single spacing after dots and colons
\frenchspacing
% \hyphenation{directembedding}
% \hyphenation{DSLVirtualization}
% \hyphenation{ReificationTransformation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        Setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\include{sections/settings}
\include{sections/cover}
\include{sections/abstract}
\begin{abstract}
  Automatic code formatters bring many benefits to software development.
  When done right, code formatters relieve the developer's attention from manipulating
  syntactic trivia while enforcing a consistent coding style between teams.
  Still, little research has been made towards the algorithms and tools that make it possible to develop such code formatters.

  This thesis addresses the problem of developing an advanced code formatter for a custom programming language.
  % A critical feature of such a formatter is enforcing a column-width limit, which turns out to be a hard problem.
  Our contributions are twofold.
  First, we present xmft, a language agnostic framework that consists of core data structures, algorithms and tooling 
  that allow rapid development and testing of such a code formatter.
  Secondly, we provide a implementation of a code formatter, \texttt{scalafmt}, that uses our framework.

  We show that the framework can support rich formatting options such as
  column-width limitation and configurable vertical alignment.
  In one month, the formatter has been installed over 2.000 times and XXX success metric.
\end{abstract}
\tableofcontents
\include{sections/introduction}
\section{Background}
\begin{enumerate}
  \item Optimal line breaking
  \item Oppen
  \item rustfmt
\end{enumerate}
\subsection{Combinator based}
\begin{enumerate}
  \item Houghes 1995
  \item Wadler 1999
\end{enumerate}
\subsection{Optimization-oriented}
\begin{enumerate}
  \item clang-format Dijkstra's 2010
  \item dartfmt Best-first search 2014
  \item rfmt 2015
\end{enumerate}
\begin{enumerate}
  \item AST integrity
  \item Idempotent
\end{enumerate}
\section{Framework}
\subsection{Data structures}
\begin{enumerate}
  \item FormatToken.
  \item Split.
  \item State.
  \item Indent.
\end{enumerate}
\subsection{Algorithms}
\begin{enumerate}
  \item Policy.
  \item OptimalToken.
  \item Best first search.
\end{enumerate}
\subsection{Tooling}
\section{scalafmt}
\subsection{scala.meta}
\subsection{Extensions}
\subsubsection{Optimizations}
\begin{enumerate}
  \item dequeueOnNewStatements
  \item recurseOnBlocks
  \item escapeInPathologicalCases
  \item pruneSlowStates
\end{enumerate}
\section{Discussion}
\subsection{Future work}
\subsection{Conclusion}
\printbibliography{}

\end{document}

