\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{float}
\usepackage[colorlinks=true,breaklinks=false]{hyperref}
\usepackage{listings}
\usepackage[norelsize,ruled,vlined]{algorithm2e}
\usepackage{csquotes}
\usepackage{url}
\usepackage{ifthen}
\usepackage{keyval}
\usepackage{etoolbox}
\usepackage{etex}
\usepackage{datetime}
\usepackage{eurosym}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{paralist}
\usepackage[backend=bibtex]{biblatex}
\usepackage{xcolor}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3} } }
\captionsetup[lstlisting]{format=listing, labelfont=white, textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize} }

\addbibresource{project.bib}

% Single spacing after dots and colons
\frenchspacing
% \hyphenation{directembedding}
% \hyphenation{DSLVirtualization}
% \hyphenation{ReificationTransformation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        Setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\include{sections/settings}
\include{sections/cover}
\include{sections/abstract}
\begin{abstract}
  Automatic code formatters bring many benefits to software development, yet they can be tricky to get right.
  This thesis addresses the problem of developing a code formatter for the
  Scala programming language that captures the language's most popular idioms
  and coding styles.
  Our work has been limited to formatting Scala code.
  Still, we have developed data structures, algorithms and tools that we believe an be applied be of interest authors of code formatters for a variety of other programming languages.
\end{abstract}
\tableofcontents
\include{sections/introduction}
\section{Introduction} % (fold)
\label{sec:Introduction}
% When done right, code formatters relieve the developer's attention from manipulating
% syntactic trivia while helping enforce a consistent coding style in codebases.
%
Code formatting brings many benefits to software development.

Code formatting aids readability of code.

Code formatting enforces a consistent coding style.

Code formatting allows developers to put their focus on what matters.

Code formatting enables automated refactoring tools.
See~\autocite{wright_large-scale_2013}

Code formatting lowers the barrier to entry for novice programmers.
Take away the decision on where to insert spaces and newlines.

Code formatters are all or nothing.

Due to their nature, either you use it for everything or for nothing.

\subsection{Problem statement}
\begin{itemize}
  \item Opinionated, can produce nice looking code even from computer generated input.
  \item Fast, must not run for longer than X per LOC.
  \item Support popular coding styles of which most important is line length limit.
\end{itemize}
\subsection{Contributions}
The main contributions presented in this thesis are the following:
\begin{itemize}
    \item Data structures, algorithms and tools for implementing advandes code formatters for syntatically rich languages.
    \item scalafmt, a case study where the framework is used to format Scala programs.
\end{itemize}
Non-goals:
\begin{itemize}
    \item Language independent pretty printing. Hasn't gained popularity.
\end{itemize}

\section{Related work}
\subsection{Combinator based}
\begin{enumerate}
  \item Houghes 1995
  \item Wadler 1999
\end{enumerate}
\subsection{Optimization-oriented}
\begin{enumerate}
  \item clang-format Dijkstra's 2010
  \item dartfmt Best-first search 2014
  \item rfmt 2015
\end{enumerate}
\begin{enumerate}
  \item Optimal line breaking
  \item Oppen
\end{enumerate}
\section{Background}
\subsection{Code formatting}
\subsection{Scala the programming language}
\subsubsection{Higher order functions}
\subsubsection{Pattern matching}
\subsubsection{Metaprogramming with scala.meta}
\begin{itemize}
  \item Tree nodes have parent links.
  \item Token classes are types.
\end{itemize}
\section{Framework}
\subsection{Data structures}
\subsubsection{FormatToken}
\subsubsection{Split combinator}
\subsubsection{Policy combinator}
\subsubsection{OptimalToken combinator}
\subsubsection{State}
\subsubsection{Indent}
\subsection{Algorithms}
Pipeline of three stages: pre-processing, line wrapping and post-processing.
\subsubsection{Pre-processing}
 \begin{itemize}
   \item AST vs. token stream
 \end{itemize}
rustfmt considers that all eventually converge to a hybrid of the two.
Indeed, clang-format has an elaborate parser.
\subsubsection{Layout}
\begin{itemize}
  \item Router
  \item Search.
\end{itemize}
\subsubsection{Post-processing}
\begin{itemize}
  \item vertical alignment
  \item comment formatting
  \item stripMargin alignment
\end{itemize}
\subsection{Tooling}
\subsubsection{Heatmaps}
\subsubsection{Unit tests}
\subsubsection{Property based testing}
\begin{enumerate}
  \item AST integrity
  \item Idempotent
\end{enumerate}
\section{scalafmt}
\subsection{Custom optimizations}
\begin{enumerate}
  \item dequeueOnNewStatements
  \item recurseOnBlocks
  \item escapeInPathologicalCases
  \item pruneSlowStates
\end{enumerate}
\section{Evaluation}
\subsection{Performance}
\subsection{Output}
\begin{itemize}
  \item gofmt
  \item rustfmt
  \item dartfmt
  \item clang-format
  \item scalariform
\end{itemize}
\section{Discussion}
\subsection{Future work}
\subsection{Conclusion}
\printbibliography{}

\end{document}

