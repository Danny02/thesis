\section{Background}
This chapter explains the necessary background to understand Scala and code formatting.
More specifically, we motivate why Scala presents an interesting challenge for code formatters.
We go into details on Scala's rich syntax and popular idioms that introduced unique challenges to the design of scalafmt.
We follow up with a brief history on code formatters for both Scala as well as other programming languages.
We will see that although code formatters have a long history, the last 5 years have brought a lot of research in optimization based formatters, which scalafmt's design takes inspiration from.

\subsection{Scala the programming language}
Scala\autocite{odersky_scala_2004} is a general purpose programming language that was first released in 2004.
Scala combines features from object-oriented and functional programming paradigms, allowing maximum code reuse and extensibility.

Scala can run on multiple platforms.
Most commonly, Scala programs compile to bytecode and run on the JVM.
With the releases of Scala.js\autocite{_scala.js_????-1}, JavaScript has recently become a popular target platform for Scala developers.
Even more recently, the announcement of Scala Native\autocite{_scala-native/scala-native_????} shows that LLVM and may become yet another viable platform for Scala developers.

Scala is a popular programming language.
The Scala Center estimates that more than half a million developers are using Scala\autocite{odersky_scala_2016}.
Large organizations such as Goldman Sachs, Twitter, IBM and Verizon run Scala code in production systems.
The 2015 Stack Overflow Developer Survey shows that Scala is the 6th most loved technology and 4th best paying technology to work with\autocite{_stack_????}.
The popularity of Apache Spark\autocite{_apache_????-1}, a cluster computing framework for large-scala data processing, has made Scala a language of choice for many developers and scientists working in big data and machine learning.

Scala is a programming language with rich syntax and many idioms.
The following chapters discuss in detail several prominent syntactic features and idioms of Scala.
Most importantly, we highlight coding patterns that encourage developers to write larger statements instead of many small statements.
In section~\ref{sec:algorithms}, we explain why large statements introduce a challenge to code formatting.

\subsubsection{Higher order functions}
Higher order functions (HOFs) are a common concept in functional programming languages and mathematics.
HOFs are functions that can take other functions as arguments and can return functions as return values.
Languages that provide a convenient syntax to manipulate HOFs are said to make functions first-class citizens.

Functions are first-class citizens in Scala.
Consider listing~\ref{lst:hof}.
\lstinputlisting[label={lst:hof}, float, caption=Higher order functions]{code/hof.scala}
The method \texttt{twice} takes an argument \texttt{f}, which is a function from an integer to an integer.
The method returns a new function that will apply \texttt{f} twice to an integer argument.
This small example takes advantage of several syntactic conveniences provided by Scala.
For example, in line 2 the argument \texttt{\_ + 3} creates a new \texttt{Function[Int, Int]} object.
The function call \texttt{f(x)} is in fact sugar for the method call \texttt{f.apply(x)} on a \texttt{Function[Int, Int]} instance.
Listing~\ref{lst:hof_nosugar} shows an equivalent program to listing~\ref{lst:hof} without syntactic sugar.
\lstinputlisting[label={lst:hof_nosugar}, float, caption=Higher order functions without syntactic sugar]{code/hof-nosugar.scala}
Observe that what was expressed as a single statement in line 1 of listing~\ref{lst:hof} is expressed with multiple statements in lines 1 and 2 of listing~\ref{lst:hof_nosugar}.

\subsubsection{Immutability}
Functional programming encourages stateless functions which operate on immutable data structures and objects.
An immutable object is an object that once initialized, cannot be modified.
Immutability offers several benefits to software development in areas including concurrency and testing.
Listing~\ref{lst:immutable} shows an example of manipulating an immutable list.
\lstinputlisting[label={lst:immutable}, float, caption=Manipulating immutable list]{code/immutable.scala}
Note that each \texttt{map} and \texttt{filter} operation creates a new copy of the list with the modified contents.
The original list remains unchanged.
Listing~\ref{lst:mutable} show the equivalent operation using a mutable list.
\lstinputlisting[label={lst:mutable}, float, caption=Manipulating mutable list]{code/mutable.scala}
Observe that what was listing~\ref{lst:immutable} is a single statement while listing~\ref{lst:mutable} is multiple statements.

\subsubsection{SBT build configuration}
SBT\autocite{_sbt_????} is an interactive build tool used by many Scala projects.
SBT configuration files are written in \texttt{*.sbt} or \texttt{*.scala} files using Scala syntax and semantics.
Although SBT configuration files use plain Scala, they typically use coding patterns which are different from traditional Scala programs.
Listing~\ref{lst:sbt} is an example project definition in SBT.
\lstinputlisting[label={lst:sbt}, float, caption=SBT project definition]{code/sbt.scala}
Observe that the project is defined as a single statement and makes extensive use of symbolic infix operators.
Due to the nature of build configurations, argument lists to can becomes unwieldy long and a single project statement can span up to dozens or even hundreds of lines of code.

% \subsection{Metaprogramming with scala.meta}
% Scala.meta\autocite{_scala.meta_????} is a robust and portable metaprogramming toolkit for Scala.
% Scala 2.10 compiler introduced the first metaprogramming API for Scala via compile-time macros and runtime reflection.
% Library authors could take advantage of this new functionality to implement more advanced features in their libraries.
% However, the Scala compiler metaprogramming facilities exposed compiler internals to its users.

\subsection{Code formatters}
%
% In the literature, the term \emph{pretty-printer} is more commonly used than code formatter.
% This thesis uses code formatter the terms are used interchangeably and the author does not distinguish between the two.} 
% We emphasize formatters that support line length length limits.
% As future sections discuss, line length limits turn out to be a big challenge to implement.

In this chapter, we look at a variety of code formatters that have been developed.

\subsubsection{Natural language}
The science of displaying aesthetically pleasing text predates as early as 1956\autocite{harris_keyboard_1956}.
The first efforts involved printing natural language text and finding the right places to insert carriage returns to break long lines.
As soon as programming languages evolved, software developers began to apply the similar ideas to source code.

LaTeX


\subsubsection{ALGOL 60}
Scowen\autocite{scowen_soapprogram_1971} developed SOAP in 1971, a code formatter for ALGOL 60.
The main motivation for SOAP was to make it ``easier for a programmer to examine and follow a program'' as well as to maintain a consistent coding style.
This motivation is still relevant in modern software development.
SOAP did provide a line length limit.
However, SOAP would fail execution if the provided line length turned out to be too small.
With hardware from 1971, SOAP could format 600 lines of code per minute.

\subsubsection{LISP}
In 1973, Goldstein\autocite{goldstein_pretty-printing_1973} explored code formatting algorithms for LISP\autocite{mccarthy_recursive_1960} programs.
LISP is a family of programming languages and is famous for it's parenthesized prefix notation.
Listing~\ref{lst:lisp} shows a program in LISP to calculate factorial numbers.
\lstinputlisting[label={lst:lisp}, float, caption=A LISP program]{code/lisp.lisp}
The simple syntax, extensive use of parentheses and nested nature of LISP programs makes them an excellent ground to study code formatters.

Goldstein presented a \emph{recursive re-predictor} algorithm in his paper.
The recursive re-predictor algorithm runs a top-down traversal on the abstract syntax tree of a LISP program.
While visiting each node, the algorithms tries to first obtain a \emph{linear-format}, i.e. fit remaining body on a single line.
If there isn't enough space on the line to fit a linear format, the algorithm falls back to \emph{standard-format} where each argument is put on a separate line aligned by the first argument.
Goldstein observes that this algorithm is practical despite the fact that its running time is exponential in the worst cases.
Bill Gosper used the re-predictor algorithm to implement GRINDEF\autocite{_bill_????}, one of the first code formatters for LISP.
Goldstein's contributions extend beyond formatting algorithms.
Firstly, in his paper he studies how to format comments.
Secondly, he presents several different formatting layouts which can be configured by the users.
Both of those concerns are relevant for modern code formatters.

\subsubsection{Language agnostic}
Derek C. Oppen pioneered the work on language agnostic code formatting in 1980\autocite{oppen_prettyprinting_1980}.
Oppen presented an algorithm is not tied to particular programming language.
The algorithms runs in linear time to the size of the input program and is incredibly memory efficient.
Users provide a preprocessor to integrate the algorithm with a particular programming language.
Besides impressive performance results, Oppen claims that a key feature of the algorithms is its streaming nature.
The algorithm prints formatted lines as soon as they are input instead of waiting until the entire input stream has been read.
However, Oppen's algorithm shares a worrying limitation with SOAP: it cannot handle the case when the line length is insufficiently large.

Mark van der Brand presented a library could generate a formatters given context-free grammar\autocite{van_den_brand_generation_1996}.
Brand correctly identifies that the development of code formatters requires a lot of effort and a generic solution may be possible.
Beyond the usual motivations for developing code formatters, Brand mentions that formatters ``relieve documentation writers from typesetting programs by hand''.
Like Oppen's algorithm, this library requires the user to translate code from a particular programming language into the library's constructs.
The library borrows the concept of a \emph{box} from Knuth\autocite{knuth_breaking_1981}.
 
John Hughes extended on Oppen's work on language agnostic formatting in term of programming techniques\autocite{hughes_design_1995}.
Hughes presented a design of a \emph{pretty-printing} library that leverages the functional programming paradigm.
Hughes says his library is a pretty-printer and not code formatters since the library does not consider how to format existing source code.
Instead, the library prints data structures directly from their values.
Wadler\autocite{wadler_prettier_2003} and Chitil\autocite{swierstra_linear_2009} extend on Hughes's and Oppen's work.
However, only in term of functional programming techniques instead of formatting or layout algorithms.



\subsubsection{clang-format}
\subsubsection{dartfmt}
\subsubsection{gofmt}
\subsubsection{rustfmt}
\subsubsection{scalariform}
There already exists a widely used code formatter for Scala called Scalariform\autocite{scalariform}.
However, Scalariform lacks the ability to enforce a column width limit,
which we consider necessary to capture many popular Scala coding styles.
