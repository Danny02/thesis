\section{Background}
This chapter explains the necessary background to understand Scala and code formatting.
More specifically, we motivate why Scala presents an interesting challenge for code formatters.
We go into details on Scala's rich syntax and popular idioms that introduced unique challenges to the design of scalafmt.
We follow up with a brief history on code formatters for both Scala as well as other programming languages.
We will see that although code formatters have a long history, the last 5 years have brought a lot of research in optimization based formatters, which scalafmt's design takes inspiration from.

\subsection{Scala the programming language}
Scala\autocite{odersky_scala_2004} is a general purpose programming language that was first released in 2004.
Scala combines features from object-oriented and functional programming paradigms, allowing maximum code reuse and extensibility.

Scala can run on multiple platforms.
Most commonly, Scala programs compile to bytecode and run on the JVM.
With the releases of Scala.js\autocite{doeraene_scala.js_2015}, JavaScript has recently become a popular target platform for Scala developers.
Even more recently, the announcement of Scala Native\autocite{_scala-native/scala-native_????} shows that LLVM and may become yet another viable platform for Scala developers.

Scala is a popular programming language.
The Scala Center estimates that more than half a million developers are using Scala\autocite{odersky_scala_2016}.
Large organizations such as Goldman Sachs, Twitter, IBM and Verizon run Scala code in production systems.
The 2015 Stack Overflow Developer Survey shows that Scala is the 6th most loved technology and 4th best paying technology to work with\autocite{_stack_????}.
The popularity of Apache Spark\autocite{_apache_????-1}, a cluster computing framework for large-scala data processing, has made Scala a language of choice for many developers and scientists working in big data and machine learning.

Scala is a programming language with rich syntax and many idioms.
The following chapters discuss in detail several prominent syntactic features and idioms of Scala.
Most importantly, we highlight coding patterns that encourage developers to write larger statements instead of many small statements.
In section~\ref{sec:algorithms}, we explain why large statements introduce a challenge to code formatting.

\subsubsection{Higher order functions}
Higher order functions (HOFs) are a common concept in functional programming languages and mathematics.
HOFs are functions that can take other functions as arguments and can return functions as return values.
Languages that provide a convenient syntax to manipulate HOFs are said to make functions first-class citizens.

Functions are first-class citizens in Scala.
Consider listing~\ref{lst:hof}.
\lstinputlisting[label={lst:hof}, float, caption=Higher order functions]{code/hof.scala}
The method \texttt{twice} takes an argument \texttt{f}, which is a function from an integer to an integer.
The method returns a new function that will apply \texttt{f} twice to an integer argument.
This small example takes advantage of several syntactic conveniences provided by Scala.
For example, in line 2 the argument \texttt{\_ + 3} creates a new \texttt{Function[Int, Int]} object.
The function call \texttt{f(x)} is in fact sugar for the method call \texttt{f.apply(x)} on a \texttt{Function[Int, Int]} instance.
Listing~\ref{lst:hof_nosugar} shows an equivalent program to listing~\ref{lst:hof} without syntactic sugar.
\lstinputlisting[label={lst:hof_nosugar}, float, caption=Higher order functions without syntactic sugar]{code/hof-nosugar.scala}
Observe that what was expressed as a single statement in line 1 of listing~\ref{lst:hof} is expressed with multiple statements in lines 1 and 2 of listing~\ref{lst:hof_nosugar}.

\subsubsection{Immutability}
Functional programming encourages stateless functions which operate on immutable data structures and objects.
An immutable object is an object that once initialized, cannot be modified.
Immutability offers several benefits to software development in areas including concurrency and testing.
Listing~\ref{lst:immutable} shows an example of manipulating an immutable list.
\lstinputlisting[label={lst:immutable}, float, caption=Manipulating immutable list]{code/immutable.scala}
Note that each \texttt{map} and \texttt{filter} operation creates a new copy of the list with the modified contents.
The original list remains unchanged.
Listing~\ref{lst:mutable} show the equivalent operation using a mutable list.
\lstinputlisting[label={lst:mutable}, float, caption=Manipulating mutable list]{code/mutable.scala}
Observe that what was listing~\ref{lst:immutable} is a single statement while listing~\ref{lst:mutable} is multiple statements.

\subsubsection{SBT build configuration}
SBT\autocite{_sbt_????} is an interactive build tool used by many Scala projects.
SBT configuration files are written in \texttt{*.sbt} or \texttt{*.scala} files using Scala syntax and semantics.
Although SBT configuration files use plain Scala, they typically use coding patterns which are different from traditional Scala programs.
Listing~\ref{lst:sbt} is an example project definition in SBT.
\lstinputlisting[label={lst:sbt}, float, caption=SBT project definition]{code/sbt.scala}
Observe that the project is defined as a single statement and makes extensive use of symbolic infix operators.
Due to the nature of build configurations, argument lists to can becomes unwieldy long and a single project statement can span up to dozens or even hundreds of lines of code.

% \subsection{Metaprogramming with scala.meta}
% Scala.meta\autocite{_scala.meta_????} is a robust and portable metaprogramming toolkit for Scala.
% Scala 2.10 compiler introduced the first metaprogramming API for Scala via compile-time macros and runtime reflection.
% Library authors could take advantage of this new functionality to implement more advanced features in their libraries.
% However, the Scala compiler metaprogramming facilities exposed compiler internals to its users.

\subsection{Code formatters}
%
% In the literature, the term \emph{pretty-printer} is more commonly used than code formatter.
% This thesis uses code formatter the terms are used interchangeably and the author does not distinguish between the two.} 
% We emphasize formatters that support line length length limits.
% As future sections discuss, line length limits turn out to be a big challenge to implement.

Code formatting and pretty printing\footnote{
  This thesis uses code formatting wherever pretty printing is concerned.
  In Hughes\autocite{hughes_design_1995} terms, pretty printing is a subset of code formatting where
  the former is only concerned with presenting data structures while the latter is
  concerned with the harder problem of formatting existing source code.} has a long tradition.
In this chapter, we look at a variety of tools and algorithm that have been developed over the last 70 years.

\subsubsection{Natural language}
The science of displaying aesthetically pleasing text predates as early as 1956\autocite{harris_keyboard_1956}.
The first efforts involved inserting carriage returns in natural language text.
Until that time, writers were responsible for manually providing carriage returns in their documents before sending them off for printing.
The motivation was to ``save operating labor and reduce human error''.
Once type-setting became more commonplace, the methods for breaking lines of text got more sophisticated.

Knuth and Plass developed a famous line breaking algorithm\autocite{knuth_breaking_1981} for \LaTeX{} in 1981.
\LaTeX is a popular typesetting program among scientific academic circles and is the program that was used to generate this very document.
The line breaking problem was the same as in the 60s: how to optimally break a paragraph of text into lines so that the right margin is minimized.
The primitive approach is to greedily fit as many words on a line as possible.
However, such an approach can produce embarrassingly bad output in the worst case.
Knuth's algorithm uses dynamic programming to find an optimal layout with regards to a fit function that penalizes empty space on the right margin of the paragraph.
This algorithm remains a textbook example of the application of dynamic programming\autocite{dreyfus2002richard}.

\subsubsection{ALGOL 60}
Scowen\autocite{scowen_soapprogram_1971} developed SOAP in 1971, a code formatter for ALGOL 60.
The main motivation for SOAP was to make it ``easier for a programmer to examine and follow a program'' as well as to maintain a consistent coding style.
This motivation is still relevant in modern software development.
SOAP did provide a line length limit.
However, SOAP would fail execution if the provided line length turned out to be too small.
With hardware from 1971, SOAP could format 600 lines of code per minute.

\subsubsection{LISP}
In 1973, Goldstein\autocite{goldstein_pretty-printing_1973} explored code formatting algorithms for LISP\autocite{mccarthy_recursive_1960} programs.
LISP is a family of programming languages and is famous for it's parenthesized prefix notation.
Listing~\ref{lst:lisp} shows a program in LISP to calculate factorial numbers.
\lstinputlisting[label={lst:lisp}, float, caption=A LISP program]{code/lisp.lisp}
The simple syntax and extensive use of parentheses as delimiters makes make LISP programs an excellent ground to study code formatters.

Goldstein presented a \emph{recursive re-predictor} algorithm in his paper.
The recursive re-predictor algorithm runs a top-down traversal on the abstract syntax tree of a LISP program.
While visiting each node, the algorithms tries to first obtain a \emph{linear-format},
i.e. fit remaining body on a single line,
with a fallback to \emph{standard-format},
i.e. each argument is put on a separate line aligned by the first argument.
Goldstein observes that this algorithm is practical despite the fact that its running time is exponential in the worst case.
Bill Gosper used the re-predictor algorithm to implement GRINDEF\autocite{_bill_????}, one of the first code formatters for LISP.

Goldstein's contributions extend beyond formatting algorithms.
Firstly, in his paper he studies how to format comments.
Secondly, he presents several different formatting layouts which can be configured by the users.
Both relevant concerns for modern code formatters.

\subsubsection{Language agnostic}\label{sec:agnostic}
Derek C. Oppen pioneered the work on language agnostic code formatting in 1980\autocite{oppen_prettyprinting_1980}.
A language agnostic formatting algorithm can be used for a variety of programming languages instead of being
tied to a single language.
Users provide a preprocessor to integrate the algorithm with a particular programming language.
Oppen's algorithm runs in $O(n)$ time and uses $O(m)$ memory for an input program of length $n$ and maximum allowed line length $m$.
Besides impressive performance results, Oppen claims that a key feature of the algorithms is its streaming nature.
The algorithm prints formatted lines as soon as they are input instead of waiting until the entire input stream has been read.
However, Oppen's algorithm shares a worrying limitation with SOAP: it cannot handle the case when the line length is insufficiently large.

Mark van der Brand presented a library could generate a formatter given a context-free grammar\autocite{van_den_brand_generation_1996}.
Brand correctly identifies that the development of code formatters requires a lot of effort.
Instead, he proposed a generic solution to the problem.
Beyond the usual motivations for developing code formatters, Brand mentions that formatters ``relieve documentation writers from typesetting programs by hand''.
The focus on documentation is reflected by the fact that generated formatter could produce both ASCII formatted code as well at \LaTeX{} markup.
Since comments are typically not included a syntax tree, the presented algorithm has an elaborate scheme to infer the location of comments in the produced output.
Like Oppen's algorithm, this library requires the user to plug in a preprocessor to integrate a particular programming language into the Brand's library.
Unlike Oppen's algorithm, Brand does not consider line length limits in his algorithm.

John Hughes extended on Oppen's work on language agnostic formatting in term of programming techniques\autocite{hughes_design_1995}.
Hughes presented a design of a \emph{pretty-printing} library that leverages the functional programming paradigm.
Hughes says his library is a pretty-printer and not code formatters since the library does not consider how to format existing source code.
Instead, the library prints data structures directly from their values.
Wadler\autocite{wadler_prettier_2003} and Chitil\autocite{swierstra_linear_2009} extend on Hughes's and Oppen's work in term of performance and functional programming techniques.
However, their contribution to formatting and layout algorithms are limited.

% More recently, Bagge and Hasu extend on Wadlers work in a language agnostic \emph{pipeline} for formatters\autocite{bagge_pretty_2013}.
% The main motivation for this work was to increase modularity and composability of format

\subsubsection{clang-format}
Daniel Jasper triggered a new trend in optimization based coded formatters with the release of \emph{ClangFormat}\autocite{jasper_clang-format_2014} in 2013.
ClangFormat was developed at Google and is a code formatter for C, C++, Java, JavaScript, Objective-C and Protobuf code.
Figure~\ref{fig:clang_format} shows the architecture of ClangFormat.
\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{img/clang-format.png}
  \caption{ClangFormat architecture}
  \label{fig:clang_format}
\end{figure}
The main components are the \emph{structural parser} and the \emph{layouter}.

ClangFormat employs a structural parser to split source code into a sequence of \emph{unwrapped-lines}.
An unwrapped line is a statement that should fit on a single line if given sufficient line length.
A key feature of unwrapped lines is that they should not influence other unwrapped lines.
The parser is lenient and parses even syntactically invalid code.
The parsed unwrapped lines are passed onto the layouter.

The ClangFormat layouter uses a novel approach to implement line wrapping.
Each line break is assigned a penalty according to several rules such as nesting and token type.
At each token, the layouter can choose to continue on the same line or break.
This forms an acyclic weighted directed graph with the first token of an unwrapped line being the root and all paths ending at the last token of the unwrapped line.
The layouter uses Dijkstra's\autocite{dijkstra_note_1959} shortest path algorithm to find the layout that has the lowest penalty.
To obtain good performance, the layouter uses several domain specific optimizations to minimize the search space.

Despite being seemingly language independent, ClangFormat does not leverage the language agnostic formatting techniques described section~\ref{sec:agnostic}.
Support for each language has been added as ad-hoc extensions to the ClangFormat parser and layouter.
ClangFormat supports a variety of configuration options, including 6 out-of-the-box styles based on coding styles from Google, LLVM and other well-known organizations.

A notable feature of ClangFormat is that it's opinionated.
ClangFormat produces well-formatted output for even the most egregiously formatted input.
Listing~\ref{lst:clang_opinion} shows an offensively formatted C++ code snippet.
\lstinputlisting[label={lst:clang_opinion}, float, caption=Unformatted C++ code]{code/terrible.cpp}
Listing~\ref{lst:clang_opinion2} shows the same snippet after being formatted with ClangFormat.
\lstinputlisting[label={lst:clang_opinion2}, float, caption=ClangFormat formatted C++ code]{code/target/unterrible.cpp}
ClangFormat is opinionated in the sense that it does not respect the user's line breaking decisions.
This feature makes it possible to ensure that all code follows the same style guide, regardless of author.

\subsubsection{dartfmt}
Dartfmt\autocite{nystrom_dart_style_2014} code formatter for the Dart programming language, developed at Google.
Like ClangFormat, dartfmt has a line length setting and is opinionated.
Bob Nystrom, the author of dartfmt, discusses the design of dartfmt in an excellent post\autocite{nystrom_hardest_2015} on his blog.
In his post, Nystrom argues that the design of a code formatters is significantly complicated by a column limit setting.
The line wrapping algorithm in dartfmt employs a \emph{best-first search}\autocite{pearl_heuristics:_1984},
a minor variant of the shortest path search in ClangFormat.
As with ClangFormat, a range of domain-specific optimizations were required to make the search scale for real-world code.
Listing~\ref{lst:dead_end} shows an example of such an optimization, \emph{avoiding dead ends}.
\lstinputlisting[label={lst:dead_end}, float, caption=Avoid dead ends]{code/dead-end.dart}
The snippets exceeds the 35 characters column limit.
A plain best-first search would explore a variety of different formatting layouts inside the argument list of \texttt{firstCall}.
However, the call to \texttt{firstCall} already fits on a line and there is no need to explore line breaks inside its argument list.
The dartfmt optimized search is able to eliminate such dead ends and quickly figure out to break before the \texttt{"long argument string"} literal.


\subsubsection{gofmt}
Gofmt\autocite{gofmt94:online} is a code formatter for the Go programming language, developed at Google.
Gofmt is noteworthy for its heavy adoption by the Go programming community.
According to official documentation\autocite{CodeR59:online}, almost all written Go code is formatted with gofmt.
Moreover, gofmt has successfully been used to automatically migrate Go codebases from legacy versions to new source-incompatible releases.
However, gofmt supports neither a column limit nor an opinionated setting.
Line breaks are preserved in the user's input.
These limitations makes gofmt less relevant for the work presented in this thesis.

% TODO?
% \subsubsection{rustfmt} 

\subsubsection{scalariform}
Scalariform\autocite{russell_scalariform_2010} is a widely used code formatter for Scala.
Scalariform does an excellent job of tidying common formatting errors and it supports a variety of configuration options.
Scalariform is also impressively fast, it can format large files with over 4.000 lines of code in under 250 milliseconds on a modern laptop.
However, like other code formatters such as gofmt, Scalariform lacks two key features: a line length and opinionated setting.

Firstly, the line length setting is necessary to implement many popular coding styles in the Scala community.
For example, the Spark\autocite{xin_spark_2015} and Scala.js\autocite{doeraene_scala.js_2015} coding styles have 100 character and 80 character column limits, respectively.
As we have learned from other code formatters, adding a line length setting is non-trivial and would require a significant redesign of Scalariform.

Secondly, the lack of an opinionated setting makes it impossible to enforce certain coding styles.
For example, the Scala.js coding style enforces \emph{bin-packing}, where arguments should be arranged compactly up to the column length limit.
Listings~\ref{lst:bin_pack} and~\ref{lst:non_bin_pack} shows an example of bin packing enabled and disabled, respectively.

\begin{minipage}{.45\textwidth}
  \lstinputlisting[label={lst:bin_pack}, caption=Bin-packing]{code/bin-pack.scala}
\end{minipage}
\hfil
\begin{minipage}{.45\textwidth}
  \lstinputlisting[label={lst:non_bin_pack}, caption=No bin-packing]{code/non-bin-pack.scala}
\end{minipage}

Since Scalariform preserves the line breaking decisions from the input,
Scalariform has no setting to convert formatted code like in listing~\ref{lst:non_bin_pack} to the code in listing~\ref{lst:bin_pack}.
